ðŸ”¥ Firestore Interview Questions & Answers (Simple English) ðŸ”¥

---

## Basic & Core Questions

1. **Difference between Firestore and Realtime Database:**

   * Firestore is more modern, has better queries, supports offline, and scales better.
   * Realtime Database is JSON tree-based, simpler but less flexible.

2. **Collections, Documents, Subcollections:**

   * Collection = group of documents.
   * Document = data object with key-value pairs.
   * Subcollection = collection inside a document. Example: `users/{uid}/notes/{noteId}`

3. **Document ID:**

   * Unique ID for a document.
   * Auto-generated by Firestore or you can set your own.

4. **Adding a Document:**

   * `add()` = Firestore generates ID.
   * `set()` = You can set a specific ID.

5. **FieldValue.serverTimestamp():**

   * Sets the field to the server time.
   * Ensures consistent timestamps across devices.

---

## Queries & Indexing

6. **Fetch notes with a specific tag:**

```dart
db.collection('users').doc(uid).collection('notes').where('tags', arrayContains: 'flutter').get();
```

7. **Where, orderBy, limit, arrayContains:**

   * `where` = filter documents.
   * `orderBy` = sort documents.
   * `limit` = get first N docs.
   * `arrayContains` = filter array fields.

8. **Missing index error:**

   * Firestore needs indexes for queries with multiple conditions.
   * Follow the console link to create them.

9. **startAt, endAt and \uf8ff:**

   * Used for prefix searches.
   * Example: names starting with 'B': `startAt(['B']).endAt(['B\uf8ff'])`

10. **Fetch first 10 notes descending:**

```dart
db.collection('users').doc(uid).collection('notes').orderBy('createdAt', descending: true).limit(10).get();
```

---

## Real-time & Streams

11. **StreamBuilder:**

* Widget that listens to a stream and updates UI automatically.

12. **.get() vs .snapshots():**

* `.get()` = one-time fetch.
* `.snapshots()` = real-time updates.

13. **Instant UI update:**

* Use `StreamBuilder` with `.snapshots()`.

14. **Offline persistence:**

* Firestore caches data locally.
* Reads/writes work without internet; syncs when online.

---

## Security & Rules

15. **request.auth.uid == userId:**

* Ensures only the logged-in user can access their own data.

16. **Restrict access to own notes:**

```js
match /users/{userId}/notes/{noteId} {
 allow read, write: if request.auth.uid == userId;
}
```

17. **Field validation in rules:**

* Check required fields, types, array size.

18. **Huge array or invalid type:**

* Firestore rejects the write if rules fail.

---

## Transactions & Batching

19. **Transaction vs Batched write:**

* Transaction = read + write atomically.
* Batched write = multiple writes/deletes together, no reads.

20. **Increment counter safely:**

* Use a transaction: read value, increment, update.

21. **Atomicity:**

* All operations succeed or none do; prevents partial updates.

---

## Optimization & Costs

22. **Firestore billing:**

* Charged per read, write, delete, and storage.

23. **Limit queries & avoid loops:**

* Each `.get()` counts as reads; loop = many reads = high cost.

24. **Pagination:**

* Use `startAfterDocument` + `limit` to load data in chunks.

25. **Scalable data model:**

* Avoid huge arrays inside docs.
* Use subcollections for user-specific data.
* Flat collections for shared/public data.

---

ðŸ’€ Brutal truth: Learn these answers by heart. Interviewers will **ask for examples**, not just theory.
